# Emerging-Sys-Arch-Tech-

For this course, I selected two project artifacts that I believe best reflect my strengths in working with embedded systems and emerging architectures: the **Thermostat.py** project and the **SOS/OK LCD Display** project. The Thermostat project transformed a breadboard setup with a Raspberry Pi into a functional thermostat. It involved reading live temperature data and allowing users to interact with the system via physical buttons to set a desired temperature threshold. This project solved the problem of simple, programmable climate control in a small embedded setup, a foundational use case for edge computing and IoT environments. The SOS/OK project, on the other hand, used a button interface to send messages to an LCD screen. Pressing one button displayed “OK,” while the other displayed “SOS,” showcasing basic human-machine interfacing (HMI) and real-time signal response. Together, these two projects demonstrate my ability to interface hardware with Python software, manage GPIO interactions, and provide real-time feedback based on user input.

In both projects, I executed the GPIO interfacing and logic control very well. I ensured that button debouncing, state handling, and LCD communication were cleanly implemented. The Thermostat.py file, specifically, features readable and modular code that could easily be expanded with additional sensors or networking capabilities in the future. One area I could improve on is implementing better exception handling and including configuration files for easier parameter tuning. Moving forward, I’m integrating tools such as GitHub for version control, Adafruit libraries for hardware abstraction, and datasheets for better component understanding into my support network. These tools make debugging and expanding functionality much easier. Skills like reading sensor input, debouncing mechanical buttons, communicating with displays, and organizing Python scripts in a clean and maintainable way are transferable to nearly any embedded or mechatronics project I take on next.

To ensure maintainability, I wrote clear, well-commented code and organized each script with defined setup and loop structures (where applicable) to separate logic and I/O. I avoided hardcoding where possible, using variables for thresholds and pin assignments. This makes the code adaptable and easier for another developer to pick up. These projects serve as a foundation for more advanced embedded systems work — whether adding wireless communication, remote control, or integrating with broader IoT architectures. I’ve demonstrated a thoughtful understanding of hardware architecture limitations and how careful design choices impact responsiveness and user experience.


